use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::process::Command;
use std::time::{SystemTime, UNIX_EPOCH};
use tauri::Manager;

use super::git::get_repo_identifier;

// =============================================================================
// GitHub Types
// =============================================================================

/// GitHub issue label
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GitHubLabel {
    pub name: String,
    pub color: String,
}

/// GitHub user/author
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GitHubAuthor {
    pub login: String,
}

/// GitHub issue from list response
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GitHubIssue {
    pub number: u32,
    pub title: String,
    pub body: Option<String>,
    pub state: String,
    pub labels: Vec<GitHubLabel>,
    pub created_at: String,
    pub author: GitHubAuthor,
}

/// GitHub comment
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GitHubComment {
    pub body: String,
    pub author: GitHubAuthor,
    pub created_at: String,
}

/// GitHub issue detail with comments (from gh issue view)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GitHubIssueDetail {
    pub number: u32,
    pub title: String,
    pub body: Option<String>,
    pub state: String,
    pub labels: Vec<GitHubLabel>,
    pub created_at: String,
    pub author: GitHubAuthor,
    #[serde(default)]
    pub comments: Vec<GitHubComment>,
}

/// Issue context to pass when creating a worktree
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IssueContext {
    pub number: u32,
    pub title: String,
    pub body: Option<String>,
    pub comments: Vec<GitHubComment>,
}

/// List GitHub issues for a repository
///
/// Uses `gh issue list` to fetch issues from the repository.
/// - state: "open", "closed", or "all" (default: "open")
/// - Returns up to 100 issues sorted by creation date (newest first)
#[tauri::command]
pub async fn list_github_issues(
    project_path: String,
    state: Option<String>,
) -> Result<Vec<GitHubIssue>, String> {
    log::trace!("Listing GitHub issues for {project_path} with state: {state:?}");

    let state_arg = state.unwrap_or_else(|| "open".to_string());

    // Run gh issue list
    let output = Command::new("gh")
        .args([
            "issue",
            "list",
            "--json",
            "number,title,body,state,labels,createdAt,author",
            "-L",
            "100",
            "--state",
            &state_arg,
        ])
        .current_dir(&project_path)
        .output()
        .map_err(|e| format!("Failed to run gh issue list: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        // Handle specific errors
        if stderr.contains("gh auth login") || stderr.contains("authentication") {
            return Err("GitHub CLI not authenticated. Run 'gh auth login' first.".to_string());
        }
        if stderr.contains("not a git repository") {
            return Err("Not a git repository".to_string());
        }
        if stderr.contains("Could not resolve") {
            return Err("Could not resolve repository. Is this a GitHub repository?".to_string());
        }
        return Err(format!("gh issue list failed: {stderr}"));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let issues: Vec<GitHubIssue> =
        serde_json::from_str(&stdout).map_err(|e| format!("Failed to parse gh response: {e}"))?;

    log::trace!("Found {} issues", issues.len());
    Ok(issues)
}

/// Search GitHub issues using GitHub's search syntax
///
/// Uses `gh issue list --search` to query GitHub's search API.
/// This finds issues beyond the default -L 100 limit.
#[tauri::command]
pub async fn search_github_issues(
    project_path: String,
    query: String,
) -> Result<Vec<GitHubIssue>, String> {
    log::trace!("Searching GitHub issues for {project_path} with query: {query}");

    let output = Command::new("gh")
        .args([
            "issue",
            "list",
            "--search",
            &query,
            "--json",
            "number,title,body,state,labels,createdAt,author",
            "-L",
            "30",
            "--state",
            "all",
        ])
        .current_dir(&project_path)
        .output()
        .map_err(|e| format!("Failed to run gh issue list --search: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        if stderr.contains("gh auth login") || stderr.contains("authentication") {
            return Err("GitHub CLI not authenticated. Run 'gh auth login' first.".to_string());
        }
        if stderr.contains("not a git repository") {
            return Err("Not a git repository".to_string());
        }
        if stderr.contains("Could not resolve") {
            return Err("Could not resolve repository. Is this a GitHub repository?".to_string());
        }
        return Err(format!("gh issue list --search failed: {stderr}"));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let issues: Vec<GitHubIssue> =
        serde_json::from_str(&stdout).map_err(|e| format!("Failed to parse gh response: {e}"))?;

    log::trace!("Search found {} issues", issues.len());
    Ok(issues)
}

/// Get detailed information about a specific GitHub issue
///
/// Uses `gh issue view` to fetch the issue with comments.
#[tauri::command]
pub async fn get_github_issue(
    project_path: String,
    issue_number: u32,
) -> Result<GitHubIssueDetail, String> {
    log::trace!("Getting GitHub issue #{issue_number} for {project_path}");

    // Run gh issue view
    let output = Command::new("gh")
        .args([
            "issue",
            "view",
            &issue_number.to_string(),
            "--json",
            "number,title,body,state,labels,createdAt,author,comments",
        ])
        .current_dir(&project_path)
        .output()
        .map_err(|e| format!("Failed to run gh issue view: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        // Handle specific errors
        if stderr.contains("gh auth login") || stderr.contains("authentication") {
            return Err("GitHub CLI not authenticated. Run 'gh auth login' first.".to_string());
        }
        if stderr.contains("Could not resolve") || stderr.contains("not found") {
            return Err(format!("Issue #{issue_number} not found"));
        }
        return Err(format!("gh issue view failed: {stderr}"));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let issue: GitHubIssueDetail =
        serde_json::from_str(&stdout).map_err(|e| format!("Failed to parse gh response: {e}"))?;

    log::trace!("Got issue #{}: {}", issue.number, issue.title);
    Ok(issue)
}

/// Generate a slug from an issue title for branch naming
/// e.g., "Fix the login bug" -> "fix-the-login-bug"
pub fn slugify_issue_title(title: &str) -> String {
    let slug: String = title
        .to_lowercase()
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == ' ' {
                c
            } else {
                ' '
            }
        })
        .collect::<String>()
        .split_whitespace()
        .take(5) // Limit to first 5 words
        .collect::<Vec<_>>()
        .join("-");

    // Limit total length
    if slug.len() > 40 {
        slug[..40].trim_end_matches('-').to_string()
    } else {
        slug
    }
}

/// Generate a branch name from an issue
/// e.g., Issue #123 "Fix the login bug" -> "issue-123-fix-the-login-bug"
pub fn generate_branch_name_from_issue(issue_number: u32, title: &str) -> String {
    let slug = slugify_issue_title(title);
    format!("issue-{issue_number}-{slug}")
}

/// Format issue context as markdown for the context file
pub fn format_issue_context_markdown(ctx: &IssueContext) -> String {
    let mut content = String::new();

    content.push_str(&format!(
        "# GitHub Issue #{}: {}\n\n",
        ctx.number, ctx.title
    ));

    content.push_str("---\n\n");

    content.push_str("## Description\n\n");
    if let Some(body) = &ctx.body {
        if !body.is_empty() {
            content.push_str(body);
        } else {
            content.push_str("*No description provided.*");
        }
    } else {
        content.push_str("*No description provided.*");
    }
    content.push_str("\n\n");

    if !ctx.comments.is_empty() {
        content.push_str("## Comments\n\n");
        for comment in &ctx.comments {
            content.push_str(&format!(
                "### @{} ({})\n\n",
                comment.author.login, comment.created_at
            ));
            content.push_str(&comment.body);
            content.push_str("\n\n---\n\n");
        }
    }

    content.push_str("---\n\n");
    content.push_str("*Investigate this issue and propose a solution.*\n");

    content
}

/// Loaded issue context info returned to frontend
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LoadedIssueContext {
    pub number: u32,
    pub title: String,
    pub comment_count: usize,
    pub repo_owner: String,
    pub repo_name: String,
}

// =============================================================================
// Shared Context Reference Tracking
// =============================================================================

/// Reference tracking for a single context file (issue or PR)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ContextRef {
    pub worktrees: Vec<String>,
    pub orphaned_at: Option<u64>,
}

/// Tracks which worktrees reference which shared context files
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ContextReferences {
    pub issues: std::collections::HashMap<String, ContextRef>,
    pub prs: std::collections::HashMap<String, ContextRef>,
}

/// Get the directory for shared GitHub contexts
pub fn get_github_contexts_dir(app: &tauri::AppHandle) -> Result<PathBuf, String> {
    let app_data_dir = app
        .path()
        .app_data_dir()
        .map_err(|e| format!("Failed to get app data directory: {e}"))?;
    Ok(app_data_dir.join("git-context"))
}

/// Get the path to the references.json file
pub fn get_references_path(app: &tauri::AppHandle) -> Result<PathBuf, String> {
    Ok(get_github_contexts_dir(app)?.join("references.json"))
}

/// Load context references from disk
pub fn load_context_references(app: &tauri::AppHandle) -> Result<ContextReferences, String> {
    let path = get_references_path(app)?;
    if !path.exists() {
        return Ok(ContextReferences::default());
    }
    let content = std::fs::read_to_string(&path)
        .map_err(|e| format!("Failed to read references.json: {e}"))?;
    serde_json::from_str(&content).map_err(|e| format!("Failed to parse references.json: {e}"))
}

/// Save context references to disk
pub fn save_context_references(
    app: &tauri::AppHandle,
    refs: &ContextReferences,
) -> Result<(), String> {
    let dir = get_github_contexts_dir(app)?;
    std::fs::create_dir_all(&dir)
        .map_err(|e| format!("Failed to create git-context directory: {e}"))?;

    let path = dir.join("references.json");
    let content = serde_json::to_string_pretty(refs)
        .map_err(|e| format!("Failed to serialize references: {e}"))?;
    std::fs::write(&path, content).map_err(|e| format!("Failed to write references.json: {e}"))
}

/// Add a worktree reference to an issue context
/// Key format: "{owner}-{repo}-{number}"
pub fn add_issue_reference(
    app: &tauri::AppHandle,
    repo_key: &str,
    issue_number: u32,
    worktree_id: &str,
) -> Result<(), String> {
    let mut refs = load_context_references(app)?;
    let key = format!("{repo_key}-{issue_number}");

    let entry = refs.issues.entry(key).or_default();
    if !entry.worktrees.contains(&worktree_id.to_string()) {
        entry.worktrees.push(worktree_id.to_string());
    }
    // Clear orphaned status when a reference is added
    entry.orphaned_at = None;

    save_context_references(app, &refs)
}

/// Add a worktree reference to a PR context
/// Key format: "{owner}-{repo}-{number}"
pub fn add_pr_reference(
    app: &tauri::AppHandle,
    repo_key: &str,
    pr_number: u32,
    worktree_id: &str,
) -> Result<(), String> {
    let mut refs = load_context_references(app)?;
    let key = format!("{repo_key}-{pr_number}");

    let entry = refs.prs.entry(key).or_default();
    if !entry.worktrees.contains(&worktree_id.to_string()) {
        entry.worktrees.push(worktree_id.to_string());
    }
    // Clear orphaned status when a reference is added
    entry.orphaned_at = None;

    save_context_references(app, &refs)
}

/// Remove a worktree reference from an issue context
/// Returns true if the context is now orphaned (no more references)
pub fn remove_issue_reference(
    app: &tauri::AppHandle,
    repo_key: &str,
    issue_number: u32,
    worktree_id: &str,
) -> Result<bool, String> {
    let mut refs = load_context_references(app)?;
    let key = format!("{repo_key}-{issue_number}");

    let orphaned = if let Some(entry) = refs.issues.get_mut(&key) {
        entry.worktrees.retain(|w| w != worktree_id);
        if entry.worktrees.is_empty() && entry.orphaned_at.is_none() {
            entry.orphaned_at = Some(
                SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs(),
            );
            true
        } else {
            false
        }
    } else {
        false
    };

    save_context_references(app, &refs)?;
    Ok(orphaned)
}

/// Remove a worktree reference from a PR context
/// Returns true if the context is now orphaned (no more references)
pub fn remove_pr_reference(
    app: &tauri::AppHandle,
    repo_key: &str,
    pr_number: u32,
    worktree_id: &str,
) -> Result<bool, String> {
    let mut refs = load_context_references(app)?;
    let key = format!("{repo_key}-{pr_number}");

    let orphaned = if let Some(entry) = refs.prs.get_mut(&key) {
        entry.worktrees.retain(|w| w != worktree_id);
        if entry.worktrees.is_empty() && entry.orphaned_at.is_none() {
            entry.orphaned_at = Some(
                SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs(),
            );
            true
        } else {
            false
        }
    } else {
        false
    };

    save_context_references(app, &refs)?;
    Ok(orphaned)
}

/// Get all issue keys referenced by a worktree
/// Returns keys in format "{owner}-{repo}-{number}"
pub fn get_worktree_issue_refs(
    app: &tauri::AppHandle,
    worktree_id: &str,
) -> Result<Vec<String>, String> {
    let refs = load_context_references(app)?;
    Ok(refs
        .issues
        .iter()
        .filter(|(_, entry)| entry.worktrees.contains(&worktree_id.to_string()))
        .map(|(key, _)| key.clone())
        .collect())
}

/// Get all PR keys referenced by a worktree
/// Returns keys in format "{owner}-{repo}-{number}"
pub fn get_worktree_pr_refs(
    app: &tauri::AppHandle,
    worktree_id: &str,
) -> Result<Vec<String>, String> {
    let refs = load_context_references(app)?;
    Ok(refs
        .prs
        .iter()
        .filter(|(_, entry)| entry.worktrees.contains(&worktree_id.to_string()))
        .map(|(key, _)| key.clone())
        .collect())
}

/// Remove all references for a worktree
/// Returns (orphaned_issue_keys, orphaned_pr_keys)
pub fn remove_all_worktree_references(
    app: &tauri::AppHandle,
    worktree_id: &str,
) -> Result<(Vec<String>, Vec<String>), String> {
    let mut refs = load_context_references(app)?;
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();

    let mut orphaned_issues = Vec::new();
    let mut orphaned_prs = Vec::new();

    for (key, entry) in refs.issues.iter_mut() {
        entry.worktrees.retain(|w| w != worktree_id);
        if entry.worktrees.is_empty() && entry.orphaned_at.is_none() {
            entry.orphaned_at = Some(now);
            orphaned_issues.push(key.clone());
        }
    }

    for (key, entry) in refs.prs.iter_mut() {
        entry.worktrees.retain(|w| w != worktree_id);
        if entry.worktrees.is_empty() && entry.orphaned_at.is_none() {
            entry.orphaned_at = Some(now);
            orphaned_prs.push(key.clone());
        }
    }

    save_context_references(app, &refs)?;
    Ok((orphaned_issues, orphaned_prs))
}

/// Parse a context key into (repo_owner, repo_name, number)
/// Key format: "{owner}-{repo}-{number}"
fn parse_context_key(key: &str) -> Option<(String, String, u32)> {
    // Split from the right to get the number first
    let (repo_key, number_str) = key.rsplit_once('-')?;
    let number = number_str.parse::<u32>().ok()?;

    // Parse repo_key as "owner-repo" - split on first dash only
    let (owner, repo) = repo_key.split_once('-')?;

    Some((owner.to_string(), repo.to_string(), number))
}

/// Clean up orphaned context files older than retention_days
/// Returns the number of files deleted
pub fn cleanup_orphaned_contexts(
    app: &tauri::AppHandle,
    retention_days: u64,
) -> Result<u32, String> {
    let mut refs = load_context_references(app)?;
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let retention_secs = retention_days * 24 * 60 * 60;

    let contexts_dir = get_github_contexts_dir(app)?;
    let mut deleted_count = 0u32;

    // Clean up orphaned issues
    let issues_to_remove: Vec<String> = refs
        .issues
        .iter()
        .filter_map(|(key, entry)| {
            if let Some(orphaned_at) = entry.orphaned_at {
                if orphaned_at + retention_secs < now {
                    return Some(key.clone());
                }
            }
            None
        })
        .collect();

    for key in &issues_to_remove {
        // File format: {repo_key}-issue-{number}.md
        // Key format: {repo_key}-{number}
        // We need to transform key to filename
        if let Some(last_dash) = key.rfind('-') {
            let repo_key = &key[..last_dash];
            let number = &key[last_dash + 1..];
            let filename = format!("{repo_key}-issue-{number}.md");
            let file_path = contexts_dir.join(&filename);
            if file_path.exists() {
                if let Err(e) = std::fs::remove_file(&file_path) {
                    log::warn!("Failed to remove orphaned issue context {filename}: {e}");
                } else {
                    deleted_count += 1;
                }
            }
        }
        refs.issues.remove(key);
    }

    // Clean up orphaned PRs
    let prs_to_remove: Vec<String> = refs
        .prs
        .iter()
        .filter_map(|(key, entry)| {
            if let Some(orphaned_at) = entry.orphaned_at {
                if orphaned_at + retention_secs < now {
                    return Some(key.clone());
                }
            }
            None
        })
        .collect();

    for key in &prs_to_remove {
        // File format: {repo_key}-pr-{number}.md
        // Key format: {repo_key}-{number}
        if let Some(last_dash) = key.rfind('-') {
            let repo_key = &key[..last_dash];
            let number = &key[last_dash + 1..];
            let filename = format!("{repo_key}-pr-{number}.md");
            let file_path = contexts_dir.join(&filename);
            if file_path.exists() {
                if let Err(e) = std::fs::remove_file(&file_path) {
                    log::warn!("Failed to remove orphaned PR context {filename}: {e}");
                } else {
                    deleted_count += 1;
                }
            }
        }
        refs.prs.remove(key);
    }

    save_context_references(app, &refs)?;
    Ok(deleted_count)
}

/// Load/refresh issue context for a worktree by fetching data from GitHub
///
/// Context is stored in shared location: `git-context/{repo_key}-issue-{number}.md`
/// Multiple worktrees can reference the same context file.
#[tauri::command]
pub async fn load_issue_context(
    app: tauri::AppHandle,
    worktree_id: String,
    issue_number: u32,
    project_path: String,
) -> Result<LoadedIssueContext, String> {
    log::trace!("Loading issue #{issue_number} context for worktree {worktree_id}");

    // Get repo identifier for shared storage
    let repo_id = get_repo_identifier(&project_path)?;
    let repo_key = repo_id.to_key();

    // Fetch issue data from GitHub
    let issue = get_github_issue(project_path, issue_number).await?;

    // Create issue context
    let ctx = IssueContext {
        number: issue.number,
        title: issue.title.clone(),
        body: issue.body,
        comments: issue.comments,
    };

    // Write to shared git-context directory
    let contexts_dir = get_github_contexts_dir(&app)?;
    std::fs::create_dir_all(&contexts_dir)
        .map_err(|e| format!("Failed to create git-context directory: {e}"))?;

    // File format: {repo_key}-issue-{number}.md
    let context_file = contexts_dir.join(format!("{repo_key}-issue-{issue_number}.md"));
    let context_content = format_issue_context_markdown(&ctx);

    std::fs::write(&context_file, context_content)
        .map_err(|e| format!("Failed to write issue context file: {e}"))?;

    // Add reference tracking
    add_issue_reference(&app, &repo_key, issue_number, &worktree_id)?;

    log::trace!(
        "Issue context loaded successfully for issue #{} ({} comments)",
        issue_number,
        ctx.comments.len()
    );

    Ok(LoadedIssueContext {
        number: issue.number,
        title: issue.title,
        comment_count: ctx.comments.len(),
        repo_owner: repo_id.owner,
        repo_name: repo_id.repo,
    })
}

/// List all loaded issue contexts for a worktree
#[tauri::command]
pub async fn list_loaded_issue_contexts(
    app: tauri::AppHandle,
    worktree_id: String,
) -> Result<Vec<LoadedIssueContext>, String> {
    log::trace!("Listing loaded issue contexts for worktree {worktree_id}");

    // Get issue refs for this worktree from reference tracking
    let issue_keys = get_worktree_issue_refs(&app, &worktree_id)?;

    if issue_keys.is_empty() {
        return Ok(vec![]);
    }

    let contexts_dir = get_github_contexts_dir(&app)?;
    let mut contexts = Vec::new();

    for key in issue_keys {
        // Parse key format: "{owner}-{repo}-{number}"
        if let Some((owner, repo, number)) = parse_context_key(&key) {
            let repo_key = format!("{owner}-{repo}");
            let context_file = contexts_dir.join(format!("{repo_key}-issue-{number}.md"));

            if let Ok(content) = std::fs::read_to_string(&context_file) {
                // Parse title from first line: "# GitHub Issue #123: Title"
                let title = content
                    .lines()
                    .next()
                    .and_then(|line| {
                        line.strip_prefix("# GitHub Issue #")
                            .and_then(|rest| rest.split_once(": "))
                            .map(|(_, title)| title.to_string())
                    })
                    .unwrap_or_else(|| format!("Issue #{number}"));

                // Count comments by counting "### @" headers
                let comment_count = content.matches("### @").count();

                contexts.push(LoadedIssueContext {
                    number,
                    title,
                    comment_count,
                    repo_owner: owner,
                    repo_name: repo,
                });
            }
        }
    }

    // Sort by issue number
    contexts.sort_by_key(|c| c.number);

    log::trace!("Found {} loaded issue contexts", contexts.len());
    Ok(contexts)
}

/// Delete all context references for a worktree
///
/// Called during worktree deletion. Uses reference tracking - marks contexts as orphaned
/// but doesn't immediately delete shared files (they'll be cleaned up later by cleanup_orphaned_contexts).
pub fn cleanup_issue_contexts_for_worktree(
    app: &tauri::AppHandle,
    worktree_id: &str,
) -> Result<(), String> {
    log::trace!("Cleaning up contexts for worktree {worktree_id}");

    // Remove all references for this worktree (handles both issues and PRs)
    let (orphaned_issues, orphaned_prs) = remove_all_worktree_references(app, worktree_id)?;

    log::trace!(
        "Marked {} issues and {} PRs as orphaned for worktree {worktree_id}",
        orphaned_issues.len(),
        orphaned_prs.len()
    );

    Ok(())
}

/// Remove a loaded issue context for a worktree
#[tauri::command]
pub async fn remove_issue_context(
    app: tauri::AppHandle,
    worktree_id: String,
    issue_number: u32,
    project_path: String,
) -> Result<(), String> {
    log::trace!("Removing issue #{issue_number} context for worktree {worktree_id}");

    // Get repo identifier
    let repo_id = get_repo_identifier(&project_path)?;
    let repo_key = repo_id.to_key();

    // Remove reference
    let is_orphaned = remove_issue_reference(&app, &repo_key, issue_number, &worktree_id)?;

    // If orphaned, delete the shared file immediately
    if is_orphaned {
        let contexts_dir = get_github_contexts_dir(&app)?;
        let context_file = contexts_dir.join(format!("{repo_key}-issue-{issue_number}.md"));

        if context_file.exists() {
            std::fs::remove_file(&context_file)
                .map_err(|e| format!("Failed to remove issue context file: {e}"))?;
            log::trace!("Deleted orphaned issue context file");
        }
    }

    log::trace!("Issue context removed successfully");
    Ok(())
}

// =============================================================================
// GitHub Pull Request Types and Commands
// =============================================================================

/// GitHub pull request from list response
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GitHubPullRequest {
    pub number: u32,
    pub title: String,
    pub body: Option<String>,
    pub state: String,
    pub head_ref_name: String,
    pub base_ref_name: String,
    pub is_draft: bool,
    pub created_at: String,
    pub author: GitHubAuthor,
    #[serde(default)]
    pub labels: Vec<GitHubLabel>,
}

/// GitHub review
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GitHubReview {
    pub body: String,
    pub state: String,
    pub author: GitHubAuthor,
    pub submitted_at: Option<String>,
}

/// GitHub PR detail with comments and reviews
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GitHubPullRequestDetail {
    pub number: u32,
    pub title: String,
    pub body: Option<String>,
    pub state: String,
    pub head_ref_name: String,
    pub base_ref_name: String,
    pub is_draft: bool,
    pub created_at: String,
    pub author: GitHubAuthor,
    #[serde(default)]
    pub labels: Vec<GitHubLabel>,
    #[serde(default)]
    pub comments: Vec<GitHubComment>,
    #[serde(default)]
    pub reviews: Vec<GitHubReview>,
}

/// PR context to pass when creating a worktree
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PullRequestContext {
    pub number: u32,
    pub title: String,
    pub body: Option<String>,
    pub head_ref_name: String,
    pub base_ref_name: String,
    pub comments: Vec<GitHubComment>,
    pub reviews: Vec<GitHubReview>,
    pub diff: Option<String>,
}

/// Loaded PR context info returned to frontend
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LoadedPullRequestContext {
    pub number: u32,
    pub title: String,
    pub comment_count: usize,
    pub review_count: usize,
    pub repo_owner: String,
    pub repo_name: String,
}

/// List GitHub pull requests for a repository
///
/// Uses `gh pr list` to fetch PRs from the repository.
/// - state: "open", "closed", "merged", or "all" (default: "open")
/// - Returns up to 100 PRs sorted by creation date (newest first)
#[tauri::command]
pub async fn list_github_prs(
    project_path: String,
    state: Option<String>,
) -> Result<Vec<GitHubPullRequest>, String> {
    log::trace!("Listing GitHub PRs for {project_path} with state: {state:?}");

    let state_arg = state.unwrap_or_else(|| "open".to_string());

    // Run gh pr list
    let output = Command::new("gh")
        .args([
            "pr",
            "list",
            "--json",
            "number,title,body,state,headRefName,baseRefName,isDraft,createdAt,author,labels",
            "-L",
            "100",
            "--state",
            &state_arg,
        ])
        .current_dir(&project_path)
        .output()
        .map_err(|e| format!("Failed to run gh pr list: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        if stderr.contains("gh auth login") || stderr.contains("authentication") {
            return Err("GitHub CLI not authenticated. Run 'gh auth login' first.".to_string());
        }
        if stderr.contains("not a git repository") {
            return Err("Not a git repository".to_string());
        }
        if stderr.contains("Could not resolve") {
            return Err("Could not resolve repository. Is this a GitHub repository?".to_string());
        }
        return Err(format!("gh pr list failed: {stderr}"));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let prs: Vec<GitHubPullRequest> =
        serde_json::from_str(&stdout).map_err(|e| format!("Failed to parse gh response: {e}"))?;

    log::trace!("Found {} PRs", prs.len());
    Ok(prs)
}

/// Search GitHub pull requests using GitHub's search syntax
///
/// Uses `gh pr list --search` to query GitHub's search API.
/// This finds PRs beyond the default -L 100 limit.
#[tauri::command]
pub async fn search_github_prs(
    project_path: String,
    query: String,
) -> Result<Vec<GitHubPullRequest>, String> {
    log::trace!("Searching GitHub PRs for {project_path} with query: {query}");

    let output = Command::new("gh")
        .args([
            "pr",
            "list",
            "--search",
            &query,
            "--json",
            "number,title,body,state,headRefName,baseRefName,isDraft,createdAt,author,labels",
            "-L",
            "30",
            "--state",
            "all",
        ])
        .current_dir(&project_path)
        .output()
        .map_err(|e| format!("Failed to run gh pr list --search: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        if stderr.contains("gh auth login") || stderr.contains("authentication") {
            return Err("GitHub CLI not authenticated. Run 'gh auth login' first.".to_string());
        }
        if stderr.contains("not a git repository") {
            return Err("Not a git repository".to_string());
        }
        if stderr.contains("Could not resolve") {
            return Err("Could not resolve repository. Is this a GitHub repository?".to_string());
        }
        return Err(format!("gh pr list --search failed: {stderr}"));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let prs: Vec<GitHubPullRequest> =
        serde_json::from_str(&stdout).map_err(|e| format!("Failed to parse gh response: {e}"))?;

    log::trace!("Search found {} PRs", prs.len());
    Ok(prs)
}

/// Get detailed information about a specific GitHub PR
///
/// Uses `gh pr view` to fetch the PR with comments and reviews.
#[tauri::command]
pub async fn get_github_pr(
    project_path: String,
    pr_number: u32,
) -> Result<GitHubPullRequestDetail, String> {
    log::trace!("Getting GitHub PR #{pr_number} for {project_path}");

    // Run gh pr view
    let output = Command::new("gh")
        .args([
            "pr",
            "view",
            &pr_number.to_string(),
            "--json",
            "number,title,body,state,headRefName,baseRefName,isDraft,createdAt,author,labels,comments,reviews",
        ])
        .current_dir(&project_path)
        .output()
        .map_err(|e| format!("Failed to run gh pr view: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        if stderr.contains("gh auth login") || stderr.contains("authentication") {
            return Err("GitHub CLI not authenticated. Run 'gh auth login' first.".to_string());
        }
        if stderr.contains("Could not resolve") || stderr.contains("not found") {
            return Err(format!("PR #{pr_number} not found"));
        }
        return Err(format!("gh pr view failed: {stderr}"));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let pr: GitHubPullRequestDetail =
        serde_json::from_str(&stdout).map_err(|e| format!("Failed to parse gh response: {e}"))?;

    log::trace!("Got PR #{}: {}", pr.number, pr.title);
    Ok(pr)
}

/// Generate a branch name from a PR
/// e.g., PR #123 "Fix the login bug" -> "pr-123-fix-the-login-bug"
pub fn generate_branch_name_from_pr(pr_number: u32, title: &str) -> String {
    let slug = slugify_issue_title(title);
    format!("pr-{pr_number}-{slug}")
}

/// Format PR context as markdown for the context file
pub fn format_pr_context_markdown(ctx: &PullRequestContext) -> String {
    let mut content = String::new();

    content.push_str(&format!(
        "# GitHub Pull Request #{}: {}\n\n",
        ctx.number, ctx.title
    ));

    content.push_str(&format!(
        "**Branch:** `{}` â†’ `{}`\n\n",
        ctx.head_ref_name, ctx.base_ref_name
    ));

    content.push_str("---\n\n");

    content.push_str("## Description\n\n");
    if let Some(body) = &ctx.body {
        if !body.is_empty() {
            content.push_str(body);
        } else {
            content.push_str("*No description provided.*");
        }
    } else {
        content.push_str("*No description provided.*");
    }
    content.push_str("\n\n");

    if !ctx.reviews.is_empty() {
        content.push_str("## Reviews\n\n");
        for review in &ctx.reviews {
            let submitted = review.submitted_at.as_deref().unwrap_or("Unknown date");
            content.push_str(&format!(
                "### @{} - {} ({})\n\n",
                review.author.login, review.state, submitted
            ));
            if !review.body.is_empty() {
                content.push_str(&review.body);
                content.push_str("\n\n");
            }
            content.push_str("---\n\n");
        }
    }

    if !ctx.comments.is_empty() {
        content.push_str("## Comments\n\n");
        for comment in &ctx.comments {
            content.push_str(&format!(
                "### @{} ({})\n\n",
                comment.author.login, comment.created_at
            ));
            content.push_str(&comment.body);
            content.push_str("\n\n---\n\n");
        }
    }

    // Add diff section if available
    if let Some(diff) = &ctx.diff {
        if !diff.is_empty() {
            content.push_str("## Changes (Diff)\n\n");
            content.push_str("```diff\n");
            content.push_str(diff);
            if !diff.ends_with('\n') {
                content.push('\n');
            }
            content.push_str("```\n\n");
        }
    }

    content.push_str("---\n\n");
    content.push_str("*Review this pull request and provide feedback or make changes.*\n");

    content
}

/// Get the diff for a PR using `gh pr diff`
///
/// Returns the diff as a string, truncated to 100KB if too large.
pub fn get_pr_diff(project_path: &str, pr_number: u32) -> Result<String, String> {
    log::debug!("Fetching diff for PR #{pr_number} in {project_path}");

    let output = Command::new("gh")
        .args(["pr", "diff", &pr_number.to_string(), "--color", "never"])
        .current_dir(project_path)
        .output()
        .map_err(|e| format!("Failed to run gh pr diff: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        log::debug!("gh pr diff failed: {stderr}");
        // Return empty string on failure (diff might not be available)
        return Ok(String::new());
    }

    let diff = String::from_utf8_lossy(&output.stdout).to_string();
    log::debug!("Got diff for PR #{pr_number}: {} bytes", diff.len());

    // Truncate if > 100KB
    const MAX_DIFF_SIZE: usize = 100_000;
    if diff.len() > MAX_DIFF_SIZE {
        Ok(format!(
            "{}...\n\n[Diff truncated at 100KB - {} bytes total. Run `gh pr diff {}` to see the full diff.]",
            &diff[..MAX_DIFF_SIZE],
            diff.len(),
            pr_number
        ))
    } else {
        Ok(diff)
    }
}

/// Load/refresh PR context for a worktree by fetching data from GitHub
///
/// Context is stored in shared location: `git-context/{repo_key}-pr-{number}.md`
/// Multiple worktrees can reference the same context file.
#[tauri::command]
pub async fn load_pr_context(
    app: tauri::AppHandle,
    worktree_id: String,
    pr_number: u32,
    project_path: String,
) -> Result<LoadedPullRequestContext, String> {
    log::trace!("Loading PR #{pr_number} context for worktree {worktree_id}");

    // Get repo identifier for shared storage
    let repo_id = get_repo_identifier(&project_path)?;
    let repo_key = repo_id.to_key();

    // Fetch PR data from GitHub
    let pr = get_github_pr(project_path.clone(), pr_number).await?;

    // Fetch the diff
    let diff = get_pr_diff(&project_path, pr_number).ok();

    // Create PR context
    let ctx = PullRequestContext {
        number: pr.number,
        title: pr.title.clone(),
        body: pr.body,
        head_ref_name: pr.head_ref_name,
        base_ref_name: pr.base_ref_name,
        comments: pr.comments,
        reviews: pr.reviews.clone(),
        diff,
    };

    // Write to shared git-context directory
    let contexts_dir = get_github_contexts_dir(&app)?;
    std::fs::create_dir_all(&contexts_dir)
        .map_err(|e| format!("Failed to create git-context directory: {e}"))?;

    // File format: {repo_key}-pr-{number}.md
    let context_file = contexts_dir.join(format!("{repo_key}-pr-{pr_number}.md"));
    let context_content = format_pr_context_markdown(&ctx);

    std::fs::write(&context_file, context_content)
        .map_err(|e| format!("Failed to write PR context file: {e}"))?;

    // Add reference tracking
    add_pr_reference(&app, &repo_key, pr_number, &worktree_id)?;

    log::debug!(
        "PR context loaded successfully for PR #{} ({} comments, {} reviews, diff: {} bytes)",
        pr_number,
        ctx.comments.len(),
        ctx.reviews.len(),
        ctx.diff.as_ref().map(|d| d.len()).unwrap_or(0)
    );

    Ok(LoadedPullRequestContext {
        number: pr.number,
        title: pr.title,
        comment_count: ctx.comments.len(),
        review_count: pr.reviews.len(),
        repo_owner: repo_id.owner,
        repo_name: repo_id.repo,
    })
}

/// List all loaded PR contexts for a worktree
#[tauri::command]
pub async fn list_loaded_pr_contexts(
    app: tauri::AppHandle,
    worktree_id: String,
) -> Result<Vec<LoadedPullRequestContext>, String> {
    log::trace!("Listing loaded PR contexts for worktree {worktree_id}");

    // Get PR refs for this worktree from reference tracking
    let pr_keys = get_worktree_pr_refs(&app, &worktree_id)?;

    if pr_keys.is_empty() {
        return Ok(vec![]);
    }

    let contexts_dir = get_github_contexts_dir(&app)?;
    let mut contexts = Vec::new();

    for key in pr_keys {
        // Parse key format: "{owner}-{repo}-{number}"
        if let Some((owner, repo, number)) = parse_context_key(&key) {
            let repo_key = format!("{owner}-{repo}");
            let context_file = contexts_dir.join(format!("{repo_key}-pr-{number}.md"));

            if let Ok(content) = std::fs::read_to_string(&context_file) {
                // Parse title from first line: "# GitHub Pull Request #123: Title"
                let title = content
                    .lines()
                    .next()
                    .and_then(|line| {
                        line.strip_prefix("# GitHub Pull Request #")
                            .and_then(|rest| rest.split_once(": "))
                            .map(|(_, title)| title.to_string())
                    })
                    .unwrap_or_else(|| format!("PR #{number}"));

                // Count comments by counting "### @" headers in Comments section
                let comment_count = content
                    .find("## Comments")
                    .map(|start| content[start..].matches("### @").count())
                    .unwrap_or(0);

                // Count reviews by counting "### @" headers in Reviews section
                let review_count = content
                    .find("## Reviews")
                    .map(|start| {
                        let reviews_section = &content[start..];
                        let end = reviews_section
                            .find("## Comments")
                            .unwrap_or(reviews_section.len());
                        reviews_section[..end].matches("### @").count()
                    })
                    .unwrap_or(0);

                contexts.push(LoadedPullRequestContext {
                    number,
                    title,
                    comment_count,
                    review_count,
                    repo_owner: owner,
                    repo_name: repo,
                });
            }
        }
    }

    // Sort by PR number
    contexts.sort_by_key(|c| c.number);

    log::trace!("Found {} loaded PR contexts", contexts.len());
    Ok(contexts)
}

/// Delete all PR context files for a worktree
///
/// This is a no-op since cleanup is handled by cleanup_issue_contexts_for_worktree
/// which calls remove_all_worktree_references for both issues and PRs.
pub fn cleanup_pr_contexts_for_worktree(
    _app: &tauri::AppHandle,
    _worktree_id: &str,
) -> Result<(), String> {
    // Cleanup is handled by cleanup_issue_contexts_for_worktree
    // which calls remove_all_worktree_references for both issues and PRs
    Ok(())
}

/// Remove a loaded PR context for a worktree
#[tauri::command]
pub async fn remove_pr_context(
    app: tauri::AppHandle,
    worktree_id: String,
    pr_number: u32,
    project_path: String,
) -> Result<(), String> {
    log::trace!("Removing PR #{pr_number} context for worktree {worktree_id}");

    // Get repo identifier
    let repo_id = get_repo_identifier(&project_path)?;
    let repo_key = repo_id.to_key();

    // Remove reference
    let is_orphaned = remove_pr_reference(&app, &repo_key, pr_number, &worktree_id)?;

    // If orphaned, delete the shared file immediately
    if is_orphaned {
        let contexts_dir = get_github_contexts_dir(&app)?;
        let context_file = contexts_dir.join(format!("{repo_key}-pr-{pr_number}.md"));

        if context_file.exists() {
            std::fs::remove_file(&context_file)
                .map_err(|e| format!("Failed to remove PR context file: {e}"))?;
            log::trace!("Deleted orphaned PR context file");
        }
    }

    log::trace!("PR context removed successfully");
    Ok(())
}

/// Get the content of a loaded issue context file
#[tauri::command]
pub async fn get_issue_context_content(
    app: tauri::AppHandle,
    worktree_id: String,
    issue_number: u32,
    project_path: String,
) -> Result<String, String> {
    // Get repo identifier
    let repo_id = get_repo_identifier(&project_path)?;
    let repo_key = repo_id.to_key();

    // Verify this worktree has a reference to this context
    let refs = get_worktree_issue_refs(&app, &worktree_id)?;
    let expected_key = format!("{repo_key}-{issue_number}");
    if !refs.contains(&expected_key) {
        return Err(format!(
            "Worktree does not have issue #{issue_number} loaded"
        ));
    }

    let contexts_dir = get_github_contexts_dir(&app)?;
    let context_file = contexts_dir.join(format!("{repo_key}-issue-{issue_number}.md"));

    if !context_file.exists() {
        return Err(format!(
            "Issue context file not found for issue #{issue_number}"
        ));
    }

    std::fs::read_to_string(&context_file)
        .map_err(|e| format!("Failed to read issue context file: {e}"))
}

/// Get the content of a loaded PR context file
#[tauri::command]
pub async fn get_pr_context_content(
    app: tauri::AppHandle,
    worktree_id: String,
    pr_number: u32,
    project_path: String,
) -> Result<String, String> {
    // Get repo identifier
    let repo_id = get_repo_identifier(&project_path)?;
    let repo_key = repo_id.to_key();

    // Verify this worktree has a reference to this context
    let refs = get_worktree_pr_refs(&app, &worktree_id)?;
    let expected_key = format!("{repo_key}-{pr_number}");
    if !refs.contains(&expected_key) {
        return Err(format!("Worktree does not have PR #{pr_number} loaded"));
    }

    let contexts_dir = get_github_contexts_dir(&app)?;
    let context_file = contexts_dir.join(format!("{repo_key}-pr-{pr_number}.md"));

    if !context_file.exists() {
        return Err(format!("PR context file not found for PR #{pr_number}"));
    }

    std::fs::read_to_string(&context_file)
        .map_err(|e| format!("Failed to read PR context file: {e}"))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_slugify_issue_title() {
        assert_eq!(
            slugify_issue_title("Fix the login bug"),
            "fix-the-login-bug"
        );
        // Apostrophe becomes space, so "can't" -> "can t" -> "can-t"
        assert_eq!(
            slugify_issue_title("Bug: can't save file"),
            "bug-can-t-save-file"
        );
        assert_eq!(slugify_issue_title("UPPERCASE Title"), "uppercase-title");
        assert_eq!(
            slugify_issue_title("Very long title that should be truncated to five words only"),
            "very-long-title-that-should"
        );
    }

    #[test]
    fn test_generate_branch_name_from_issue() {
        assert_eq!(
            generate_branch_name_from_issue(123, "Fix the login bug"),
            "issue-123-fix-the-login-bug"
        );
        assert_eq!(
            generate_branch_name_from_issue(42, "Add new feature"),
            "issue-42-add-new-feature"
        );
    }

    #[test]
    fn test_generate_branch_name_from_pr() {
        assert_eq!(
            generate_branch_name_from_pr(456, "Fix authentication"),
            "pr-456-fix-authentication"
        );
    }

    #[test]
    fn test_parse_context_key() {
        // Standard case: owner-repo-number
        assert_eq!(
            parse_context_key("owner-repo-123"),
            Some(("owner".to_string(), "repo".to_string(), 123))
        );

        // Repo with dash (splits on first dash for owner)
        assert_eq!(
            parse_context_key("owner-my-repo-456"),
            Some(("owner".to_string(), "my-repo".to_string(), 456))
        );

        // Invalid cases
        assert_eq!(parse_context_key("invalid"), None);
        assert_eq!(parse_context_key("repo-abc"), None);
        assert_eq!(parse_context_key("single"), None);
    }
}
